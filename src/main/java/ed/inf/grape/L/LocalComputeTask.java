package ed.inf.grape.L;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import ed.inf.grape.core.Message;
import ed.inf.grape.core.Query;
import ed.inf.grape.core.Result;
import ed.inf.grape.graph.Edge;
import ed.inf.grape.graph.Partition;

public class LocalComputeTask {

	/** ass the query to this task */
	private Query query;

	/** assign a partition to this task */
	private int partitionID;

	/** step count */
	private int superstep;

	/** messages generated by this step */
	private List<Message> generatedMessages;

	/** results generated by this step */
	private Result generatedResult;

	static Logger log = LogManager.getLogger(LocalComputeTask.class);

	public LocalComputeTask(Query query, int partitionID) {
		this.partitionID = partitionID;
		this.query = query;
		this.superstep = 0;
		this.generatedMessages = new ArrayList<Message>();
		this.generatedResult = new Result();
	}

	public void prepareForNextCompute() {

		/**
		 * Clear messages. for the next compute.s
		 * */

		this.generatedMessages.clear();
		this.superstep++;
	}

	public int getPartitionID() {
		return this.partitionID;
	}

	public int getSuperstep() {
		return this.superstep;
	}

	public List<Message> getMessages() {
		/**
		 * return the messages generated by this local compute.
		 */
		return (this.generatedMessages.size() == 0) ? null
				: this.generatedMessages;
	}

	public Result getResult() {
		/**
		 * return the results generated by this local compute.
		 */
		return this.generatedResult;
	}

	public void compute(Partition partition) {
		/**
		 * a method need to implemented by client
		 * 
		 * define compute, also fulfil messages and results.
		 * 
		 */
		log.debug("local compute.");

	}

	public void incrementalCompute(Partition partition,
			List<Message> incomingMessages) {
		/**
		 * a method need to implemented by client
		 * 
		 * define compute, also fulfil messages and results.
		 * 
		 */
		log.debug("local incremental compute.");

		// **page rank*/

		log.debug("incommingMessages.size = " + incomingMessages.size());

		Map<Integer, Double> aggregateByVertex = new HashMap<Integer, Double>();
		for (Message m : incomingMessages) {
			double oldv = aggregateByVertex.getOrDefault(
					m.getDestinationVertexID(), 0.0);
			aggregateByVertex.put(m.getDestinationVertexID(),
					oldv + m.getContent());
		}

		log.debug("aggregateIncommingMessages.size = "
				+ aggregateByVertex.size());

		for (Entry<Integer, Double> entry : aggregateByVertex.entrySet()) {

			int source = entry.getKey();
			int numOutgoingEdges = partition.outDegreeOf(source);

			if (this.getSuperstep() < 10) {

				double updatedRank = (0.15 / numOutgoingEdges + 0.85 * entry
						.getValue());

				this.generatedResult.ranks.put(source, updatedRank);

				for (Edge edge : partition.outgoingEdgesOf(source)) {

					Message message = new Message(
							partition.getEdgeTarget(edge), updatedRank
									/ numOutgoingEdges);
					this.generatedMessages.add(message);

				}
			} else {
				// volt to halt
			}
		}

	}
}
