package ed.inf.grape.interfaces;

import java.util.ArrayList;
import java.util.List;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import ed.inf.grape.graph.Partition;
import ed.inf.grape.util.KV;

public abstract class LocalComputeTask {

	/** ass the query to this task */
	private Query query;

	/** assign a partition to this task */
	private int partitionID;

	/** step count */
	private int superstep;

	/** messages generated by this step */
	private List<Message> generatedMessages;

	/** results generated by this step */
	private Result generatedResult;

	static Logger log = LogManager.getLogger(LocalComputeTask.class);

	public void init(Query query, int partitionID) {
		this.partitionID = partitionID;
		this.query = query;
		this.superstep = 0;
		this.generatedMessages = new ArrayList<Message>();
		try {
			this.generatedResult = (Result) Class.forName(KV.CLASS_RESULT)
					.newInstance();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void prepareForNextCompute() {
		/** Clear messages. for the next compute. */
		this.generatedMessages.clear();
		this.superstep++;
	}

	public int getPartitionID() {
		return this.partitionID;
	}

	public int getSuperstep() {
		return this.superstep;
	}

	public List<Message> getMessages() {
		/**
		 * return the messages generated by this local compute.
		 */
		return this.generatedMessages;
	}

	public Result getResult() {
		/**
		 * return the results generated by this local compute.
		 */
		return this.generatedResult;
	}

	public abstract void compute(Partition partition);

	public abstract void incrementalCompute(Partition partition,
			List<Message> incomingMessages);
}
